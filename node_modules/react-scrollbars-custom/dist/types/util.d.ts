/// <reference types="react" />
import { ElementPropsWithElementRefAndRenderer, ElementRef } from "./types";
export declare function isUndef(v: any): boolean;
export declare function isFun(v: any): boolean;
export declare function isNum(v: any): boolean;
/**
 * @description Will return renderer result if presented, div element otherwise.
 * If renderer is presented it'll receive `elementRef` function which should be used as HTMLElement's ref.
 *
 * @param props {ElementPropsWithElementRefAndRenderer}
 * @param elementRef {ElementRef}
 */
export declare function renderDivWithRenderer(props: ElementPropsWithElementRefAndRenderer, elementRef: ElementRef): JSX.Element | null;
/**
 * @description Return element's height without padding
 *
 * ts-ignore here is okay here, because it brigs around 40% of performance
 */
export declare const getInnerHeight: (el: HTMLDivElement) => number;
/**
 * @description Return element's width without padding
 *
 * ts-ignore here is okay here, because it brigs around 40% of performance
 */
export declare const getInnerWidth: (el: HTMLDivElement) => number;
/**
 * @description Return element's dimensions without padding
 *
 * ts-ignore here is okay here, because it brigs around 40% of performance
 */
export declare const getInnerDimensions: (el: HTMLDivElement) => {
    width: number;
    height: number;
};
/**
 * @description Return unique UUID v4
 */
export declare const uuid: () => string;
/**
 * @description Calculate thumb size for given viewport and track parameters
 *
 * @param {number} contentSize - Scrollable content size
 * @param {number} viewportSize - Viewport size
 * @param {number} trackSize - Track size thumb can move
 * @param {number} minimalSize - Minimal thumb's size
 * @param {number} maximalSize - Maximal thumb's size
 */
export declare function calcThumbSize(contentSize: number, viewportSize: number, trackSize: number, minimalSize?: number, maximalSize?: number): number;
/**
 * @description Calculate thumb offset for given viewport, track and thumb parameters
 *
 * @param {number} contentSize - Scrollable content size
 * @param {number} viewportSize - Viewport size
 * @param {number} trackSize - Track size thumb can move
 * @param {number} thumbSize - Thumb size
 * @param {number} scroll - Scroll value to represent
 */
export declare function calcThumbOffset(contentSize: number, viewportSize: number, trackSize: number, thumbSize: number, scroll: number): number;
/**
 * @description Calculate scroll for given viewport, track and thumb parameters
 *
 * @param {number} contentSize - Scrollable content size
 * @param {number} viewportSize - Viewport size
 * @param {number} trackSize - Track size thumb can move
 * @param {number} thumbSize - Thumb size
 * @param {number} thumbOffset - Thumb's offset representing the scroll
 */
export declare function calcScrollForThumbOffset(contentSize: number, viewportSize: number, trackSize: number, thumbSize: number, thumbOffset: number): number;
/**
 * @description Returns scrollbar width specific for current environment
 */
export declare function getScrollbarWidth(force?: boolean): number;
/**
 * @description Set the cached width to given value.<br/>
 *              <i>null</i> will force to recalculate value on next get.
 */
export declare const _dbgSetScrollbarWidth: (v: number | null) => number | null;
/**
 * @description Set the document node to calculate the scrollbar width.<br/>
 *              <i>null</i> will force getter to return 0 (it'll imitate SSR).
 */
export declare const _dbgSetDocument: (v: Document | null) => Document | null;
/**
 * @description Return current document node
 */
export declare const _dbgGetDocument: () => Document | null;
/**
 * @description Detect need of horizontal scroll reverse while RTL
 */
export declare const shouldReverseRTLScroll: (force?: boolean) => boolean;
/**
 * @description Set the cached value to given value.<br/>
 *              <i>null</i> will force to recalculate value on next get.
 */
export declare const _dbgSetIsReverseRTLScrollNeeded: (v: boolean | null) => boolean | null;
